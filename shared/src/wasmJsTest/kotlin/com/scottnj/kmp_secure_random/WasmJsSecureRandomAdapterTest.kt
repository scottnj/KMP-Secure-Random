package com.scottnj.kmp_secure_random

import kotlin.test.*

/**
 * Unit tests for WasmJsSecureRandomAdapter.
 * Tests WASM-JS-specific functionality and adapter behavior including fallback policies.
 */
class WasmJsSecureRandomAdapterTest {

    /**
     * Test that WasmJsSecureRandomAdapter can be created successfully.
     */
    @Test
    fun testAdapterCreation() {
        val result = WasmJsSecureRandomAdapter.create()
        assertTrue(result.isSuccess, "WasmJsSecureRandomAdapter should be created successfully")

        val adapter = result.getOrNull()
        assertNotNull(adapter, "Adapter should not be null")
    }

    /**
     * Test that createSecureRandom returns WASM-JS implementation.
     */
    @Test
    fun testCreateSecureRandomReturnsWasmJsImplementation() {
        val result = createSecureRandom()
        assertTrue(result.isSuccess, "createSecureRandom should succeed on WASM-JS")

        val secureRandom = result.getOrNull()
        assertNotNull(secureRandom, "SecureRandom should not be null")
    }

    /**
     * Test basic random byte generation.
     */
    @Test
    fun testBasicRandomByteGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextBytes with array
        val bytes = ByteArray(32)
        val result = secureRandom.nextBytes(bytes)
        assertTrue(result.isSuccess, "nextBytes should succeed")

        // Verify bytes are not all zeros
        assertFalse(bytes.all { it == 0.toByte() }, "Generated bytes should not all be zero")

        // Test nextBytes with size
        val generatedBytes = secureRandom.nextBytes(16).getOrThrow()
        assertEquals(16, generatedBytes.size, "Generated byte array should have correct size")
        assertFalse(generatedBytes.all { it == 0.toByte() }, "Generated bytes should not all be zero")
    }

    /**
     * Test random integer generation.
     */
    @Test
    fun testRandomIntegerGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextInt()
        val intResult = secureRandom.nextInt()
        assertTrue(intResult.isSuccess, "nextInt should succeed")

        // Test nextInt(bound)
        val boundedIntResult = secureRandom.nextInt(100)
        assertTrue(boundedIntResult.isSuccess, "nextInt with bound should succeed")
        val boundedInt = boundedIntResult.getOrThrow()
        assertTrue(boundedInt >= 0 && boundedInt < 100, "Bounded int should be in range [0, 100)")

        // Test nextInt(min, max)
        val rangedIntResult = secureRandom.nextInt(10, 20)
        assertTrue(rangedIntResult.isSuccess, "nextInt with range should succeed")
        val rangedInt = rangedIntResult.getOrThrow()
        assertTrue(rangedInt >= 10 && rangedInt < 20, "Ranged int should be in range [10, 20)")
    }

    /**
     * Test random long generation.
     */
    @Test
    fun testRandomLongGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextLong()
        val longResult = secureRandom.nextLong()
        assertTrue(longResult.isSuccess, "nextLong should succeed")

        // Test nextLong(bound)
        val boundedLongResult = secureRandom.nextLong(1000L)
        assertTrue(boundedLongResult.isSuccess, "nextLong with bound should succeed")
        val boundedLong = boundedLongResult.getOrThrow()
        assertTrue(boundedLong >= 0L && boundedLong < 1000L, "Bounded long should be in range [0, 1000)")

        // Test nextLong(min, max)
        val rangedLongResult = secureRandom.nextLong(100L, 200L)
        assertTrue(rangedLongResult.isSuccess, "nextLong with range should succeed")
        val rangedLong = rangedLongResult.getOrThrow()
        assertTrue(rangedLong >= 100L && rangedLong < 200L, "Ranged long should be in range [100, 200)")
    }

    /**
     * Test random boolean generation.
     */
    @Test
    fun testRandomBooleanGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        val booleanResult = secureRandom.nextBoolean()
        assertTrue(booleanResult.isSuccess, "nextBoolean should succeed")

        val boolean = booleanResult.getOrThrow()
        assertTrue(boolean is Boolean, "Result should be a boolean")

        // Generate multiple booleans to check distribution
        val booleans = (1..100).map { secureRandom.nextBoolean().getOrThrow() }
        val trueCount = booleans.count { it }
        val falseCount = booleans.count { !it }

        // Both true and false should appear (statistical check)
        assertTrue(trueCount > 0, "Should generate some true values")
        assertTrue(falseCount > 0, "Should generate some false values")
    }

    /**
     * Test random double generation.
     */
    @Test
    fun testRandomDoubleGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        val doubleResult = secureRandom.nextDouble()
        assertTrue(doubleResult.isSuccess, "nextDouble should succeed")

        val double = doubleResult.getOrThrow()
        assertTrue(double >= 0.0 && double < 1.0, "Double should be in range [0.0, 1.0)")
    }

    /**
     * Test random float generation.
     */
    @Test
    fun testRandomFloatGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        val floatResult = secureRandom.nextFloat()
        assertTrue(floatResult.isSuccess, "nextFloat should succeed")

        val float = floatResult.getOrThrow()
        assertTrue(float >= 0.0f && float < 1.0f, "Float should be in range [0.0, 1.0)")
    }

    /**
     * Test parameter validation for invalid bounds.
     */
    @Test
    fun testParameterValidation() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test invalid int bound
        val invalidIntBoundResult = secureRandom.nextInt(0)
        assertTrue(invalidIntBoundResult.isFailure, "nextInt with zero bound should fail")

        // Test invalid long bound
        val invalidLongBoundResult = secureRandom.nextLong(0L)
        assertTrue(invalidLongBoundResult.isFailure, "nextLong with zero bound should fail")

        // Test invalid range
        val invalidRangeResult = secureRandom.nextInt(10, 5)
        assertTrue(invalidRangeResult.isFailure, "nextInt with invalid range should fail")

        // Test empty byte array
        val emptyBytes = ByteArray(0)
        val emptyBytesResult = secureRandom.nextBytes(emptyBytes)
        assertTrue(emptyBytesResult.isFailure, "nextBytes with empty array should fail")

        // Test negative size
        val negativeSizeResult = secureRandom.nextBytes(-1)
        assertTrue(negativeSizeResult.isFailure, "nextBytes with negative size should fail")
    }

    /**
     * Test WASM-JS memory handling characteristics.
     */
    @Test
    fun testWasmJsMemoryHandling() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test multiple memory allocations
        val results = mutableListOf<ByteArray>()
        repeat(10) {
            val result = secureRandom.nextBytes(64).getOrThrow()
            results.add(result)
        }

        assertEquals(10, results.size, "Should generate 10 byte arrays")

        // Check that all arrays have correct size and content
        results.forEach { bytes ->
            assertEquals(64, bytes.size, "Each byte array should have correct size")
            assertFalse(bytes.all { it == 0.toByte() }, "Each array should have non-zero content")
        }

        // Check that arrays are different (very unlikely to be the same)
        val uniqueArrays = results.map { it.contentHashCode() }.toSet()
        assertTrue(uniqueArrays.size > 1, "Should generate different arrays")
    }

    /**
     * Test error handling in WASM-JS environment.
     */
    @Test
    fun testWasmJsErrorHandling() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test large byte array generation
        val largeBytesResult = secureRandom.nextBytes(1024)
        assertTrue(largeBytesResult.isSuccess, "Should handle large byte arrays in WASM")

        val largeBytes = largeBytesResult.getOrThrow()
        assertEquals(1024, largeBytes.size, "Large byte array should have correct size")

        // Test multiple operations after potential memory pressure
        val intResult = secureRandom.nextInt(10)
        assertTrue(intResult.isSuccess, "Should work after large operation")

        val longResult = secureRandom.nextLong(100L)
        assertTrue(longResult.isSuccess, "Should work after large operation")
    }

    /**
     * Test statistical properties for WASM-JS implementation.
     */
    @Test
    fun testWasmJsStatisticalProperties() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Generate small set of random integers and check basic properties
        val integers = (1..50).map { secureRandom.nextInt(100).getOrThrow() }

        // Check range
        assertTrue(integers.all { it >= 0 && it < 100 }, "All integers should be in range [0, 100)")

        // Check that we get some variety (not all the same)
        val uniqueIntegers = integers.toSet()
        assertTrue(uniqueIntegers.size > 1, "Should generate different integer values")

        // Generate bytes and check basic properties
        val bytes = secureRandom.nextBytes(100).getOrThrow()
        val uniqueBytes = bytes.toSet()
        assertTrue(uniqueBytes.size > 10, "Should generate varied byte values")
    }

    /**
     * Test WASM-JS specific edge cases.
     */
    @Test
    fun testWasmJsEdgeCases() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test boundary values for WASM number handling
        val maxInt = secureRandom.nextInt(Int.MAX_VALUE)
        assertTrue(maxInt.isSuccess, "Should handle Int.MAX_VALUE bound")

        val maxLong = secureRandom.nextLong(Long.MAX_VALUE)
        assertTrue(maxLong.isSuccess, "Should handle Long.MAX_VALUE bound")

        // Test zero and one bounds
        assertEquals(0, secureRandom.nextInt(1).getOrThrow(), "nextInt(1) should return 0")
        assertEquals(0L, secureRandom.nextLong(1L).getOrThrow(), "nextLong(1) should return 0")

        // Test empty byte array
        val emptyArray = secureRandom.nextBytes(0).getOrThrow()
        assertEquals(0, emptyArray.size, "Empty array should have size 0")
    }

    /**
     * Test rapid successive operations in WASM-JS.
     */
    @Test
    fun testRapidSuccessiveOperations() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Perform many operations in rapid succession
        val results = mutableListOf<Int>()
        repeat(100) {
            val result = secureRandom.nextInt(1000).getOrThrow()
            results.add(result)
        }

        assertEquals(100, results.size, "Should generate 100 results")

        // Check that not all results are the same
        val uniqueResults = results.toSet()
        assertTrue(uniqueResults.size > 1, "Should generate different values")

        // All should be in range
        assertTrue(results.all { it >= 0 && it < 1000 }, "All results should be in range")
    }

    /**
     * Test secure-only fallback policy (default behavior).
     */
    @Test
    @OptIn(AllowInsecureFallback::class)
    fun testSecureOnlyFallbackPolicy() {
        // Test default behavior (should work with Web Crypto API if available)
        val defaultResult = createSecureRandom()
        assertTrue(defaultResult.isSuccess, "Default createSecureRandom should succeed")

        // Test explicit SECURE_ONLY policy
        val secureOnlyResult = createSecureRandom(FallbackPolicy.SECURE_ONLY)
        assertTrue(secureOnlyResult.isSuccess, "SECURE_ONLY policy should succeed when Web Crypto available")

        val secureRandom = secureOnlyResult.getOrThrow()
        val bytes = ByteArray(16)
        val bytesResult = secureRandom.nextBytes(bytes)
        assertTrue(bytesResult.isSuccess, "Random generation should work with SECURE_ONLY")
    }

    /**
     * Test insecure fallback policy with explicit opt-in.
     */
    @Test
    @OptIn(AllowInsecureFallback::class)
    fun testInsecureFallbackPolicy() {
        // Test ALLOW_INSECURE policy (should work regardless of Web Crypto availability)
        val insecureResult = createSecureRandom(FallbackPolicy.ALLOW_INSECURE)
        assertTrue(insecureResult.isSuccess, "ALLOW_INSECURE policy should succeed")

        val secureRandom = insecureResult.getOrThrow()

        // Test basic functionality works
        val bytes = ByteArray(16)
        val bytesResult = secureRandom.nextBytes(bytes)
        assertTrue(bytesResult.isSuccess, "Random generation should work with ALLOW_INSECURE")

        // Verify bytes are generated (not all zeros)
        assertFalse(bytes.all { it == 0.toByte() }, "Generated bytes should not all be zero")

        // Test integer generation
        val intResult = secureRandom.nextInt(100)
        assertTrue(intResult.isSuccess, "Integer generation should work with ALLOW_INSECURE")
        val intValue = intResult.getOrThrow()
        assertTrue(intValue >= 0 && intValue < 100, "Generated int should be in range")
    }

    /**
     * Test adapter creation with different fallback policies.
     */
    @Test
    @OptIn(AllowInsecureFallback::class)
    fun testAdapterCreationWithFallbackPolicies() {
        // Test secure-only adapter creation
        val secureOnlyResult = WasmJsSecureRandomAdapter.create(FallbackPolicy.SECURE_ONLY)
        assertTrue(secureOnlyResult.isSuccess, "Should create adapter with SECURE_ONLY policy")

        // Test insecure fallback adapter creation
        val insecureResult = WasmJsSecureRandomAdapter.create(FallbackPolicy.ALLOW_INSECURE)
        assertTrue(insecureResult.isSuccess, "Should create adapter with ALLOW_INSECURE policy")

        // Both adapters should work for basic operations
        val secureAdapter = secureOnlyResult.getOrThrow()
        val insecureAdapter = insecureResult.getOrThrow()

        val secureBytes = ByteArray(8)
        val insecureBytes = ByteArray(8)

        assertTrue(secureAdapter.nextBytes(secureBytes).isSuccess, "Secure adapter should work")
        assertTrue(insecureAdapter.nextBytes(insecureBytes).isSuccess, "Insecure adapter should work")
    }

    /**
     * Test that fallback policy is properly enforced across different random generation methods.
     */
    @Test
    @OptIn(AllowInsecureFallback::class)
    fun testFallbackPolicyConsistency() {
        val secureRandom = createSecureRandom(FallbackPolicy.ALLOW_INSECURE).getOrThrow()

        // Test all random generation methods work consistently
        assertTrue(secureRandom.nextBytes(ByteArray(4)).isSuccess, "nextBytes(array) should work")
        assertTrue(secureRandom.nextBytes(4).isSuccess, "nextBytes(size) should work")
        assertTrue(secureRandom.nextInt().isSuccess, "nextInt() should work")
        assertTrue(secureRandom.nextInt(100).isSuccess, "nextInt(bound) should work")
        assertTrue(secureRandom.nextInt(10, 20).isSuccess, "nextInt(min, max) should work")
        assertTrue(secureRandom.nextLong().isSuccess, "nextLong() should work")
        assertTrue(secureRandom.nextLong(1000L).isSuccess, "nextLong(bound) should work")
        assertTrue(secureRandom.nextLong(100L, 200L).isSuccess, "nextLong(min, max) should work")
        assertTrue(secureRandom.nextBoolean().isSuccess, "nextBoolean() should work")
        assertTrue(secureRandom.nextDouble().isSuccess, "nextDouble() should work")
        assertTrue(secureRandom.nextFloat().isSuccess, "nextFloat() should work")
    }

    /**
     * Test backward compatibility - existing code should continue to work.
     */
    @Test
    fun testBackwardCompatibility() {
        // Test that the original createSecureRandom() still works
        val result = createSecureRandom()
        assertTrue(result.isSuccess, "Original createSecureRandom() should still work")

        val secureRandom = result.getOrThrow()

        // Test that it behaves like SECURE_ONLY policy
        val bytes = ByteArray(16)
        val bytesResult = secureRandom.nextBytes(bytes)
        assertTrue(bytesResult.isSuccess, "Should work like SECURE_ONLY policy")

        // Test integer generation for good measure
        val intResult = secureRandom.nextInt(50)
        assertTrue(intResult.isSuccess, "Integer generation should work")
        val intValue = intResult.getOrThrow()
        assertTrue(intValue >= 0 && intValue < 50, "Generated int should be in range")
    }
}