package com.scottnj.kmp_secure_random

import kotlin.test.*

/**
 * Unit tests for JsSecureRandomAdapter.
 * Tests JavaScript-specific functionality and adapter behavior.
 */
class JsSecureRandomAdapterTest {

    /**
     * Test that JsSecureRandomAdapter can be created successfully.
     */
    @Test
    fun testAdapterCreation() {
        val result = JsSecureRandomAdapter.create()
        assertTrue(result.isSuccess, "JsSecureRandomAdapter should be created successfully")

        val adapter = result.getOrNull()
        assertNotNull(adapter, "Adapter should not be null")
    }

    /**
     * Test that createSecureRandom returns JavaScript implementation.
     */
    @Test
    fun testCreateSecureRandomReturnsJavaScriptImplementation() {
        val result = createSecureRandom()
        assertTrue(result.isSuccess, "createSecureRandom should succeed on JavaScript")

        val secureRandom = result.getOrNull()
        assertNotNull(secureRandom, "SecureRandom should not be null")
    }

    /**
     * Test basic random byte generation.
     */
    @Test
    fun testBasicRandomByteGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextBytes with array
        val bytes = ByteArray(32)
        val result = secureRandom.nextBytes(bytes)
        assertTrue(result.isSuccess, "nextBytes should succeed")

        // Verify bytes are not all zeros
        assertFalse(bytes.all { it == 0.toByte() }, "Generated bytes should not all be zero")

        // Test nextBytes with size
        val generatedBytes = secureRandom.nextBytes(16).getOrThrow()
        assertEquals(16, generatedBytes.size, "Generated byte array should have correct size")
        assertFalse(generatedBytes.all { it == 0.toByte() }, "Generated bytes should not all be zero")
    }

    /**
     * Test random integer generation.
     */
    @Test
    fun testRandomIntegerGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextInt()
        val intResult = secureRandom.nextInt()
        assertTrue(intResult.isSuccess, "nextInt should succeed")

        // Test nextInt(bound)
        val boundedIntResult = secureRandom.nextInt(100)
        assertTrue(boundedIntResult.isSuccess, "nextInt with bound should succeed")
        val boundedInt = boundedIntResult.getOrThrow()
        assertTrue(boundedInt >= 0 && boundedInt < 100, "Bounded int should be in range [0, 100)")

        // Test nextInt(min, max)
        val rangedIntResult = secureRandom.nextInt(10, 20)
        assertTrue(rangedIntResult.isSuccess, "nextInt with range should succeed")
        val rangedInt = rangedIntResult.getOrThrow()
        assertTrue(rangedInt >= 10 && rangedInt < 20, "Ranged int should be in range [10, 20)")
    }

    /**
     * Test random long generation.
     */
    @Test
    fun testRandomLongGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextLong()
        val longResult = secureRandom.nextLong()
        assertTrue(longResult.isSuccess, "nextLong should succeed")

        // Test nextLong(bound)
        val boundedLongResult = secureRandom.nextLong(1000L)
        assertTrue(boundedLongResult.isSuccess, "nextLong with bound should succeed")
        val boundedLong = boundedLongResult.getOrThrow()
        assertTrue(boundedLong >= 0L && boundedLong < 1000L, "Bounded long should be in range [0, 1000)")

        // Test nextLong(min, max)
        val rangedLongResult = secureRandom.nextLong(100L, 200L)
        assertTrue(rangedLongResult.isSuccess, "nextLong with range should succeed")
        val rangedLong = rangedLongResult.getOrThrow()
        assertTrue(rangedLong >= 100L && rangedLong < 200L, "Ranged long should be in range [100, 200)")
    }

    /**
     * Test random boolean generation.
     */
    @Test
    fun testRandomBooleanGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        val booleanResult = secureRandom.nextBoolean()
        assertTrue(booleanResult.isSuccess, "nextBoolean should succeed")

        val boolean = booleanResult.getOrThrow()
        assertTrue(boolean is Boolean, "Result should be a boolean")

        // Generate multiple booleans to check distribution
        val booleans = (1..100).map { secureRandom.nextBoolean().getOrThrow() }
        val trueCount = booleans.count { it }
        val falseCount = booleans.count { !it }

        // Both true and false should appear (statistical check)
        assertTrue(trueCount > 0, "Should generate some true values")
        assertTrue(falseCount > 0, "Should generate some false values")
    }

    /**
     * Test random double generation.
     */
    @Test
    fun testRandomDoubleGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        val doubleResult = secureRandom.nextDouble()
        assertTrue(doubleResult.isSuccess, "nextDouble should succeed")

        val double = doubleResult.getOrThrow()
        assertTrue(double >= 0.0 && double < 1.0, "Double should be in range [0.0, 1.0)")
    }

    /**
     * Test random float generation.
     */
    @Test
    fun testRandomFloatGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        val floatResult = secureRandom.nextFloat()
        assertTrue(floatResult.isSuccess, "nextFloat should succeed")

        val float = floatResult.getOrThrow()
        assertTrue(float >= 0.0f && float < 1.0f, "Float should be in range [0.0, 1.0)")
    }

    /**
     * Test parameter validation for invalid bounds.
     */
    @Test
    fun testParameterValidation() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test invalid int bound
        val invalidIntBoundResult = secureRandom.nextInt(0)
        assertTrue(invalidIntBoundResult.isFailure, "nextInt with zero bound should fail")

        // Test invalid long bound
        val invalidLongBoundResult = secureRandom.nextLong(0L)
        assertTrue(invalidLongBoundResult.isFailure, "nextLong with zero bound should fail")

        // Test invalid range
        val invalidRangeResult = secureRandom.nextInt(10, 5)
        assertTrue(invalidRangeResult.isFailure, "nextInt with invalid range should fail")

        // Test empty byte array
        val emptyBytes = ByteArray(0)
        val emptyBytesResult = secureRandom.nextBytes(emptyBytes)
        assertTrue(emptyBytesResult.isFailure, "nextBytes with empty array should fail")

        // Test negative size
        val negativeSizeResult = secureRandom.nextBytes(-1)
        assertTrue(negativeSizeResult.isFailure, "nextBytes with negative size should fail")
    }

    /**
     * Test thread safety by performing concurrent operations.
     * Note: This is a basic test - JavaScript is single-threaded in browsers.
     */
    @Test
    fun testBasicConcurrentAccess() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Perform multiple operations in sequence (simulating concurrent access)
        val results = mutableListOf<Int>()
        repeat(10) {
            val result = secureRandom.nextInt(1000).getOrThrow()
            results.add(result)
        }

        assertEquals(10, results.size, "Should generate 10 results")

        // Check that not all results are the same (very unlikely with secure random)
        val uniqueResults = results.toSet()
        assertTrue(uniqueResults.size > 1, "Should generate different values")
    }

    /**
     * Test error handling and recovery.
     */
    @Test
    fun testErrorHandling() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test large byte array generation
        val largeBytesResult = secureRandom.nextBytes(1024)
        assertTrue(largeBytesResult.isSuccess, "Should handle large byte arrays")

        val largeBytes = largeBytesResult.getOrThrow()
        assertEquals(1024, largeBytes.size, "Large byte array should have correct size")

        // Test multiple operations after potential errors
        val intResult = secureRandom.nextInt(10)
        assertTrue(intResult.isSuccess, "Should work after large operation")
    }

    /**
     * Test statistical properties of generated random numbers.
     */
    @Test
    fun testBasicStatisticalProperties() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Generate small set of random integers and check basic properties
        val integers = (1..50).map { secureRandom.nextInt(100).getOrThrow() }

        // Check range
        assertTrue(integers.all { it >= 0 && it < 100 }, "All integers should be in range [0, 100)")

        // Check that we get some variety (not all the same)
        val uniqueIntegers = integers.toSet()
        assertTrue(uniqueIntegers.size > 1, "Should generate different integer values")

        // Generate bytes and check basic properties
        val bytes = secureRandom.nextBytes(100).getOrThrow()
        val uniqueBytes = bytes.toSet()
        assertTrue(uniqueBytes.size > 10, "Should generate varied byte values")
    }
}