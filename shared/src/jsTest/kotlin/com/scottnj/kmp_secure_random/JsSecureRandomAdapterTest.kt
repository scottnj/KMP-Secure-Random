package com.scottnj.kmp_secure_random

import kotlin.test.*

/**
 * JavaScript-specific tests for JsSecureRandomAdapter.
 *
 * Focuses on JavaScript unique features rather than basic operations
 * (which are already covered in commonTest):
 * - Web Crypto API integration verification
 * - TypedArray (Uint8Array) integration
 * - Node.js vs Browser environment detection
 * - JavaScript-specific runtime behavior
 *
 * Basic functionality tests are covered in commonTest.
 */
class JsSecureRandomAdapterTest {

    /**
     * Test that JsSecureRandomAdapter can be created successfully.
     */
    @Test
    fun testAdapterCreation() {
        val result = JsSecureRandomAdapter.create()
        assertTrue(result.isSuccess, "JsSecureRandomAdapter should be created successfully")

        val adapter = result.getOrNull()
        assertNotNull(adapter, "Adapter should not be null")
    }

    /**
     * Test that createSecureRandom returns JavaScript implementation.
     */
    @Test
    fun testCreateSecureRandomReturnsJavaScriptImplementation() {
        val result = createSecureRandom()
        assertTrue(result.isSuccess, "createSecureRandom should succeed on JavaScript")

        val secureRandom = result.getOrNull()
        assertNotNull(secureRandom, "SecureRandom should not be null")
    }

    /**
     * Test Web Crypto API and Node.js crypto module integration.
     * This is the critical platform-specific test that verifies actual crypto API usage.
     */
    @Test
    fun testWebCryptoAndNodeCryptoIntegration() {
        // Test that we can access the underlying crypto APIs
        val cryptoAvailable = js("""
            (function() {
                // Check for Web Crypto API (browsers)
                if (typeof crypto !== 'undefined' &&
                    typeof crypto.getRandomValues === 'function') {
                    return 'WebCrypto';
                }

                // Check for Node.js crypto module
                if (typeof require !== 'undefined') {
                    try {
                        var nodeCrypto = require('crypto');
                        if (nodeCrypto && typeof nodeCrypto.randomBytes === 'function') {
                            return 'NodeCrypto';
                        }
                    } catch (e) {
                        // require not available or crypto module not found
                    }
                }

                return 'None';
            })()
        """).toString()

        assertTrue(
            cryptoAvailable == "WebCrypto" || cryptoAvailable == "NodeCrypto",
            "Should have access to either Web Crypto API or Node.js crypto module, found: $cryptoAvailable"
        )

        // Test that our implementation actually works with the detected API
        val secureRandom = createSecureRandom().getOrThrow()
        val bytes = ByteArray(32)
        val result = secureRandom.nextBytes(bytes)
        assertTrue(result.isSuccess, "$cryptoAvailable should generate random bytes successfully")

        assertFalse(bytes.all { it == 0.toByte() }, "Generated bytes should not all be zero")

        println("✅ JavaScript crypto integration verified: $cryptoAvailable")
    }

    /**
     * Test TypedArray (Uint8Array) integration which is used by crypto.getRandomValues.
     * Critical test for ensuring proper integration with JavaScript's binary data handling.
     */
    @Test
    fun testTypedArrayIntegration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Generate multiple byte arrays to test TypedArray handling
        val sizes = listOf(1, 8, 16, 32, 64, 256, 1024)

        sizes.forEach { size ->
            val bytes = ByteArray(size)
            val result = secureRandom.nextBytes(bytes)
            assertTrue(result.isSuccess, "TypedArray handling should work for size $size")

            // Verify the bytes were actually modified
            val nonZeroCount = bytes.count { it != 0.toByte() }
            val nonZeroRatio = nonZeroCount.toDouble() / size

            // Even with random data, we should see some non-zero bytes in larger arrays
            if (size >= 8) {
                assertTrue(nonZeroRatio > 0.1, "Should have reasonable non-zero ratio for size $size: $nonZeroRatio")
            }
        }

        println("✅ TypedArray integration verified for sizes: $sizes")
    }

    /**
     * Test JavaScript environment detection and adaptation.
     */
    @Test
    fun testJavaScriptEnvironmentDetection() {
        // Test environment detection
        val environment = js("""
            (function() {
                if (typeof window !== 'undefined' && typeof document !== 'undefined') {
                    return 'Browser';
                } else if (typeof process !== 'undefined' && process.versions && process.versions.node) {
                    return 'Node.js';
                } else if (typeof self !== 'undefined') {
                    return 'WebWorker';
                } else {
                    return 'Unknown';
                }
            })()
        """).toString()

        println("Detected JavaScript environment: $environment")

        // Test that our adapter works regardless of environment
        val secureRandom = createSecureRandom().getOrThrow()
        val bytes = ByteArray(16)
        val result = secureRandom.nextBytes(bytes)
        assertTrue(result.isSuccess, "Should work in $environment environment")

        // Test multiple generations for consistency
        repeat(5) {
            val testBytes = ByteArray(8)
            val testResult = secureRandom.nextBytes(testBytes)
            assertTrue(testResult.isSuccess, "Generation $it should succeed in $environment")
        }

        println("✅ JavaScript environment adaptation verified: $environment")
    }

    /**
     * Test crypto.getRandomValues specific behavior and constraints.
     */
    @Test
    fun testCryptoGetRandomValuesSpecifics() {
        // Test if crypto.getRandomValues is available and test its constraints
        val cryptoTestResult = js("""
            (function() {
                if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
                    try {
                        // Test with Uint8Array
                        var testArray = new Uint8Array(16);
                        crypto.getRandomValues(testArray);

                        // Check if any bytes were set (very high probability)
                        var hasNonZero = false;
                        for (var i = 0; i < testArray.length; i++) {
                            if (testArray[i] !== 0) {
                                hasNonZero = true;
                                break;
                            }
                        }

                        return hasNonZero ? 'Working' : 'ZeroOutput';
                    } catch (e) {
                        return 'Error: ' + e.message;
                    }
                } else {
                    return 'NotAvailable';
                }
            })()
        """).toString()

        println("crypto.getRandomValues test result: $cryptoTestResult")

        // If Web Crypto is available, it should work
        if (cryptoTestResult == "Working") {
            // Test our adapter with various sizes that crypto.getRandomValues supports
            val secureRandom = createSecureRandom().getOrThrow()

            // Test different buffer sizes
            val testSizes = listOf(1, 16, 32, 65536) // 65536 is max for crypto.getRandomValues
            testSizes.forEach { size ->
                val bytes = ByteArray(size)
                val result = secureRandom.nextBytes(bytes)
                assertTrue(result.isSuccess, "Should handle size $size with crypto.getRandomValues")
            }
        }

        println("✅ crypto.getRandomValues specifics verified")
    }

    /**
     * Test JavaScript-specific compilation and runtime behavior.
     */
    @Test
    fun testJavaScriptSpecificBehavior() {
        // Test that the JavaScript adapter compiles and runs properly
        val adapter = JsSecureRandomAdapter.create()
        assertTrue(adapter.isSuccess, "JavaScript adapter should be created successfully")

        val secureRandom = adapter.getOrThrow()

        // Test that all method signatures work correctly in JavaScript
        val byteArrayResult = secureRandom.nextBytes(16)
        assertTrue(byteArrayResult.isSuccess, "Byte array generation should work")
        assertTrue(byteArrayResult.getOrNull() is ByteArray, "Should return ByteArray")

        val intResult = secureRandom.nextInt()
        assertTrue(intResult.isSuccess, "Int generation should work")
        assertTrue(intResult.getOrNull() is Int, "Should return Int")

        val longResult = secureRandom.nextLong()
        assertTrue(longResult.isSuccess, "Long generation should work")
        assertTrue(longResult.getOrNull() is Long, "Should return Long")

        val doubleResult = secureRandom.nextDouble()
        assertTrue(doubleResult.isSuccess, "Double generation should work")
        assertTrue(doubleResult.getOrNull() is Double, "Should return Double")

        val floatResult = secureRandom.nextFloat()
        assertTrue(floatResult.isSuccess, "Float generation should work")
        assertTrue(floatResult.getOrNull() is Float, "Should return Float")

        val booleanResult = secureRandom.nextBoolean()
        assertTrue(booleanResult.isSuccess, "Boolean generation should work")
        assertTrue(booleanResult.getOrNull() is Boolean, "Should return Boolean")

        println("✅ JavaScript-specific behavior verified")
    }

    /**
     * Test JavaScript memory management and garbage collection behavior.
     */
    @Test
    fun testJavaScriptMemoryManagement() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test rapid allocation and deallocation
        repeat(100) {
            val bytes = ByteArray(1024)
            val result = secureRandom.nextBytes(bytes)
            assertTrue(result.isSuccess, "Memory management test iteration $it should succeed")

            // Let the byte array go out of scope for GC
        }

        // Test that we can still generate after many allocations
        val finalBytes = ByteArray(32)
        val finalResult = secureRandom.nextBytes(finalBytes)
        assertTrue(finalResult.isSuccess, "Should work after memory stress test")

        println("✅ JavaScript memory management verified")
    }

    /**
     * Test JavaScript async/await compatibility (single-threaded nature).
     */
    @Test
    fun testJavaScriptAsyncCompatibility() {
        // JavaScript is single-threaded, but test sequential operations rapidly
        val secureRandom = createSecureRandom().getOrThrow()
        val results = mutableListOf<ByteArray>()

        // Rapid sequential calls (simulating async operations)
        repeat(50) {
            val bytes = ByteArray(8)
            val result = secureRandom.nextBytes(bytes)
            assertTrue(result.isSuccess, "Sequential call $it should succeed")
            results.add(bytes)
        }

        // Verify all results are unique (very high probability)
        val uniqueResults = results.map { it.contentToString() }.toSet()
        val uniquenessRatio = uniqueResults.size.toDouble() / results.size

        assertTrue(uniquenessRatio > 0.8, "Should have high uniqueness in sequential calls: $uniquenessRatio")

        println("✅ JavaScript async compatibility verified (${uniqueResults.size}/${results.size} unique)")
    }
}