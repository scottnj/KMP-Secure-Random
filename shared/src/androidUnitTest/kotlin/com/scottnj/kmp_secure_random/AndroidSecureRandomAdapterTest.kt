package com.scottnj.kmp_secure_random

import kotlin.test.*

/**
 * Unit tests for AndroidSecureRandomAdapter.
 * Tests Android-specific functionality and adapter behavior.
 */
class AndroidSecureRandomAdapterTest {

    /**
     * Test that AndroidSecureRandomAdapter can be created successfully.
     */
    @Test
    fun testAdapterCreation() {
        val result = AndroidSecureRandomAdapter.create()
        assertTrue(result.isSuccess, "AndroidSecureRandomAdapter should be created successfully")

        val adapter = result.getOrNull()
        assertNotNull(adapter, "Adapter should not be null")
    }

    /**
     * Test that createSecureRandom returns Android implementation.
     */
    @Test
    fun testCreateSecureRandomReturnsAndroidImplementation() {
        val result = createSecureRandom()
        assertTrue(result.isSuccess, "createSecureRandom should succeed on Android")

        val secureRandom = result.getOrNull()
        assertNotNull(secureRandom, "SecureRandom should not be null")
    }

    /**
     * Test basic random byte generation.
     */
    @Test
    fun testBasicRandomByteGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextBytes with array
        val bytes = ByteArray(32)
        val result = secureRandom.nextBytes(bytes)
        assertTrue(result.isSuccess, "nextBytes should succeed")

        // Verify bytes are not all zeros
        assertFalse(bytes.all { it == 0.toByte() }, "Generated bytes should not all be zero")

        // Test nextBytes with size
        val sizeResult = secureRandom.nextBytes(16)
        assertTrue(sizeResult.isSuccess, "nextBytes(size) should succeed")
        assertEquals(16, sizeResult.getOrNull()!!.size, "Should generate correct number of bytes")
    }

    /**
     * Test integer generation methods.
     */
    @Test
    fun testIntegerGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextInt()
        val intResult = secureRandom.nextInt()
        assertTrue(intResult.isSuccess, "nextInt should succeed")

        // Test nextInt(bound)
        val boundedResult = secureRandom.nextInt(100)
        assertTrue(boundedResult.isSuccess, "nextInt(bound) should succeed")
        val boundedValue = boundedResult.getOrNull()!!
        assertTrue(boundedValue >= 0 && boundedValue < 100, "Bounded int should be in range")

        // Test nextInt(min, max)
        val rangeResult = secureRandom.nextInt(10, 20)
        assertTrue(rangeResult.isSuccess, "nextInt(min, max) should succeed")
        val rangeValue = rangeResult.getOrNull()!!
        assertTrue(rangeValue >= 10 && rangeValue < 20, "Range int should be in range")
    }

    /**
     * Test long generation methods.
     */
    @Test
    fun testLongGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextLong()
        val longResult = secureRandom.nextLong()
        assertTrue(longResult.isSuccess, "nextLong should succeed")

        // Test nextLong(bound)
        val boundedResult = secureRandom.nextLong(1000L)
        assertTrue(boundedResult.isSuccess, "nextLong(bound) should succeed")
        val boundedValue = boundedResult.getOrNull()!!
        assertTrue(boundedValue >= 0L && boundedValue < 1000L, "Bounded long should be in range")

        // Test nextLong(min, max)
        val rangeResult = secureRandom.nextLong(100L, 200L)
        assertTrue(rangeResult.isSuccess, "nextLong(min, max) should succeed")
        val rangeValue = rangeResult.getOrNull()!!
        assertTrue(rangeValue >= 100L && rangeValue < 200L, "Range long should be in range")
    }

    /**
     * Test floating point generation methods.
     */
    @Test
    fun testFloatingPointGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextDouble()
        val doubleResult = secureRandom.nextDouble()
        assertTrue(doubleResult.isSuccess, "nextDouble should succeed")
        val doubleValue = doubleResult.getOrNull()!!
        assertTrue(doubleValue >= 0.0 && doubleValue < 1.0, "Double should be in [0,1)")

        // Test nextFloat()
        val floatResult = secureRandom.nextFloat()
        assertTrue(floatResult.isSuccess, "nextFloat should succeed")
        val floatValue = floatResult.getOrNull()!!
        assertTrue(floatValue >= 0.0f && floatValue < 1.0f, "Float should be in [0,1)")
    }

    /**
     * Test boolean generation.
     */
    @Test
    fun testBooleanGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        val booleanResult = secureRandom.nextBoolean()
        assertTrue(booleanResult.isSuccess, "nextBoolean should succeed")

        val booleanValue = booleanResult.getOrNull()!!
        assertTrue(booleanValue is Boolean, "Should return a boolean value")

        // Test that we get both true and false over multiple calls
        val booleans = mutableSetOf<Boolean>()
        repeat(50) {
            val result = secureRandom.nextBoolean()
            if (result.isSuccess) {
                booleans.add(result.getOrNull()!!)
            }
        }
        assertTrue(booleans.contains(true) || booleans.contains(false), "Should generate boolean values")
    }

    /**
     * Test error handling for invalid parameters.
     */
    @Test
    fun testErrorHandling() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test negative bound
        val negativeBoundResult = secureRandom.nextInt(-1)
        assertTrue(negativeBoundResult.isFailure, "Negative bound should fail")

        // Test zero bound
        val zeroBoundResult = secureRandom.nextInt(0)
        assertTrue(zeroBoundResult.isFailure, "Zero bound should fail")

        // Test invalid range
        val invalidRangeResult = secureRandom.nextInt(10, 5)
        assertTrue(invalidRangeResult.isFailure, "Invalid range should fail")

        // Test empty byte array
        val emptyArrayResult = secureRandom.nextBytes(ByteArray(0))
        assertTrue(emptyArrayResult.isFailure, "Empty byte array should fail")

        // Test negative size
        val negativeSizeResult = secureRandom.nextBytes(-1)
        assertTrue(negativeSizeResult.isFailure, "Negative size should fail")
    }

    /**
     * Test edge cases.
     */
    @Test
    fun testEdgeCases() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test bound of 1
        val boundOneResult = secureRandom.nextInt(1)
        assertTrue(boundOneResult.isSuccess, "Bound of 1 should succeed")
        assertEquals(0, boundOneResult.getOrNull()!!, "With bound 1, result should be 0")

        // Test range with difference of 1
        val rangeOneResult = secureRandom.nextInt(5, 6)
        assertTrue(rangeOneResult.isSuccess, "Range of 1 should succeed")
        assertEquals(5, rangeOneResult.getOrNull()!!, "With range [5,6), result should be 5")

        // Test zero-size byte array creation
        val zeroSizeResult = secureRandom.nextBytes(0)
        assertTrue(zeroSizeResult.isSuccess, "Zero size should succeed")
        assertEquals(0, zeroSizeResult.getOrNull()!!.size, "Should return empty array")
    }

    /**
     * Test that multiple instances produce different values.
     */
    @Test
    fun testMultipleInstancesProduceDifferentValues() {
        val instance1 = createSecureRandom().getOrThrow()
        val instance2 = createSecureRandom().getOrThrow()

        val values1 = mutableSetOf<String>()
        val values2 = mutableSetOf<String>()

        repeat(10) {
            val result1 = instance1.nextBytes(8)
            val result2 = instance2.nextBytes(8)

            if (result1.isSuccess && result2.isSuccess) {
                values1.add(result1.getOrNull()!!.contentToString())
                values2.add(result2.getOrNull()!!.contentToString())
            }
        }

        // Different instances should generally produce different sequences
        val intersection = values1.intersect(values2)
        val intersectionRatio = intersection.size.toDouble() / minOf(values1.size, values2.size)

        assertTrue(intersectionRatio < 0.5, "Different instances should produce mostly different values")
    }

    /**
     * Test Android-specific compilation and runtime behavior.
     */
    @Test
    fun testAndroidSpecificBehavior() {
        // This test verifies that the Android adapter compiles and runs
        val adapter = AndroidSecureRandomAdapter.create()
        assertTrue(adapter.isSuccess, "Android adapter should be created successfully")

        val secureRandom = adapter.getOrThrow()

        // Test that all methods are callable and return expected types
        val byteArrayResult = secureRandom.nextBytes(16)
        assertTrue(byteArrayResult.isSuccess, "Byte array generation should work")
        assertTrue(byteArrayResult.getOrNull() is ByteArray, "Should return ByteArray")

        val intResult = secureRandom.nextInt()
        assertTrue(intResult.isSuccess, "Int generation should work")
        assertTrue(intResult.getOrNull() is Int, "Should return Int")

        val longResult = secureRandom.nextLong()
        assertTrue(longResult.isSuccess, "Long generation should work")
        assertTrue(longResult.getOrNull() is Long, "Should return Long")

        val doubleResult = secureRandom.nextDouble()
        assertTrue(doubleResult.isSuccess, "Double generation should work")
        assertTrue(doubleResult.getOrNull() is Double, "Should return Double")

        val floatResult = secureRandom.nextFloat()
        assertTrue(floatResult.isSuccess, "Float generation should work")
        assertTrue(floatResult.getOrNull() is Float, "Should return Float")

        val booleanResult = secureRandom.nextBoolean()
        assertTrue(booleanResult.isSuccess, "Boolean generation should work")
        assertTrue(booleanResult.getOrNull() is Boolean, "Should return Boolean")
    }

    /**
     * Test thread safety with Android adapter.
     */
    @Test
    fun testThreadSafetyOnAndroid() {
        val secureRandom = createSecureRandom().getOrThrow()
        val results = mutableListOf<ByteArray>()
        val errors = mutableListOf<Exception>()

        val threads = List(3) { // Conservative thread count for Android
            Thread {
                try {
                    repeat(10) {
                        val result = secureRandom.nextBytes(8)
                        if (result.isSuccess) {
                            synchronized(results) {
                                results.add(result.getOrNull()!!)
                            }
                        } else {
                            synchronized(errors) {
                                errors.add(RuntimeException("Generation failed"))
                            }
                        }
                    }
                } catch (e: Exception) {
                    synchronized(errors) {
                        errors.add(e)
                    }
                }
            }
        }

        threads.forEach { it.start() }
        threads.forEach { it.join() }

        assertTrue(errors.isEmpty(), "No errors should occur during concurrent access: ${errors.firstOrNull()}")
        assertTrue(results.size >= 20, "Should generate values from multiple threads: ${results.size}")

        // Check for uniqueness
        val uniqueValues = results.map { it.contentToString() }.toSet()
        val uniquenessRatio = uniqueValues.size.toDouble() / results.size
        assertTrue(uniquenessRatio > 0.7, "Should have reasonable uniqueness across threads: $uniquenessRatio")
    }
}