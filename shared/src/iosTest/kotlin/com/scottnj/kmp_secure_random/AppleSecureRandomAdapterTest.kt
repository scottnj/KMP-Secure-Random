package com.scottnj.kmp_secure_random

import kotlin.test.*

/**
 * Unit tests for AppleSecureRandomAdapter on iOS.
 * Tests Apple SecRandomCopyBytes-specific functionality and adapter behavior.
 */
class AppleSecureRandomAdapterTest {

    /**
     * Test that AppleSecureRandomAdapter can be created successfully.
     */
    @Test
    fun testAdapterCreation() {
        val result = AppleSecureRandomAdapter.create()
        assertTrue(result.isSuccess, "AppleSecureRandomAdapter should be created successfully")

        val adapter = result.getOrNull()
        assertNotNull(adapter, "Adapter should not be null")
    }

    /**
     * Test that createSecureRandom returns Apple implementation.
     */
    @Test
    fun testCreateSecureRandomReturnsAppleImplementation() {
        val result = createSecureRandom()
        assertTrue(result.isSuccess, "createSecureRandom should succeed on iOS")

        val secureRandom = result.getOrNull()
        assertNotNull(secureRandom, "SecureRandom should not be null")
    }

    /**
     * Test basic random byte generation using SecRandomCopyBytes.
     */
    @Test
    fun testBasicRandomByteGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextBytes with array
        val bytes = ByteArray(32)
        val result = secureRandom.nextBytes(bytes)
        assertTrue(result.isSuccess, "nextBytes should succeed")

        // Verify bytes are not all zeros
        assertFalse(bytes.all { it == 0.toByte() }, "Generated bytes should not all be zero")

        // Test nextBytes with size
        val bytesResult = secureRandom.nextBytes(16)
        assertTrue(bytesResult.isSuccess, "nextBytes(size) should succeed")
        val generatedBytes = bytesResult.getOrThrow()
        assertEquals(16, generatedBytes.size, "Generated array should have correct size")
        assertFalse(generatedBytes.all { it == 0.toByte() }, "Generated bytes should not all be zero")
    }

    /**
     * Test random integer generation.
     */
    @Test
    fun testRandomIntegerGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextInt()
        val intResult = secureRandom.nextInt()
        assertTrue(intResult.isSuccess, "nextInt should succeed")

        // Test nextInt(bound)
        val boundedIntResult = secureRandom.nextInt(100)
        assertTrue(boundedIntResult.isSuccess, "nextInt(bound) should succeed")
        val boundedInt = boundedIntResult.getOrThrow()
        assertTrue(boundedInt >= 0 && boundedInt < 100, "Bounded int should be in range [0, 100)")

        // Test nextInt(min, max)
        val rangeIntResult = secureRandom.nextInt(10, 20)
        assertTrue(rangeIntResult.isSuccess, "nextInt(min, max) should succeed")
        val rangeInt = rangeIntResult.getOrThrow()
        assertTrue(rangeInt >= 10 && rangeInt < 20, "Range int should be in range [10, 20)")
    }

    /**
     * Test random long generation.
     */
    @Test
    fun testRandomLongGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextLong()
        val longResult = secureRandom.nextLong()
        assertTrue(longResult.isSuccess, "nextLong should succeed")

        // Test nextLong(bound)
        val boundedLongResult = secureRandom.nextLong(1000L)
        assertTrue(boundedLongResult.isSuccess, "nextLong(bound) should succeed")
        val boundedLong = boundedLongResult.getOrThrow()
        assertTrue(boundedLong >= 0L && boundedLong < 1000L, "Bounded long should be in range [0, 1000)")

        // Test nextLong(min, max)
        val rangeLongResult = secureRandom.nextLong(100L, 200L)
        assertTrue(rangeLongResult.isSuccess, "nextLong(min, max) should succeed")
        val rangeLong = rangeLongResult.getOrThrow()
        assertTrue(rangeLong >= 100L && rangeLong < 200L, "Range long should be in range [100, 200)")
    }

    /**
     * Test random boolean generation.
     */
    @Test
    fun testRandomBooleanGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        val booleanResult = secureRandom.nextBoolean()
        assertTrue(booleanResult.isSuccess, "nextBoolean should succeed")

        // Test multiple generations to ensure variety
        val booleans = (1..20).map { secureRandom.nextBoolean().getOrThrow() }
        assertTrue(booleans.contains(true) || booleans.contains(false), "Should generate boolean values")
    }

    /**
     * Test random float and double generation.
     */
    @Test
    fun testRandomFloatingPointGeneration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextFloat()
        val floatResult = secureRandom.nextFloat()
        assertTrue(floatResult.isSuccess, "nextFloat should succeed")
        val floatValue = floatResult.getOrThrow()
        assertTrue(floatValue >= 0.0f && floatValue < 1.0f, "Float should be in range [0.0, 1.0)")

        // Test nextDouble()
        val doubleResult = secureRandom.nextDouble()
        assertTrue(doubleResult.isSuccess, "nextDouble should succeed")
        val doubleValue = doubleResult.getOrThrow()
        assertTrue(doubleValue >= 0.0 && doubleValue < 1.0, "Double should be in range [0.0, 1.0)")
    }

    /**
     * Test error handling for invalid parameters.
     */
    @Test
    fun testErrorHandlingForInvalidParameters() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test nextInt with invalid bound
        val invalidBoundResult = secureRandom.nextInt(0)
        assertTrue(invalidBoundResult.isFailure, "nextInt(0) should fail")

        // Test nextInt with invalid range
        val invalidRangeResult = secureRandom.nextInt(10, 5)
        assertTrue(invalidRangeResult.isFailure, "nextInt(10, 5) should fail")

        // Test nextBytes with negative size
        val negativeSizeResult = secureRandom.nextBytes(-1)
        assertTrue(negativeSizeResult.isFailure, "nextBytes(-1) should fail")
    }

    /**
     * Test Apple-specific SecRandomCopyBytes functionality.
     */
    @Test
    fun testSecRandomCopyBytesIntegration() {
        val result = AppleSecureRandomAdapter.create()
        assertTrue(result.isSuccess, "Should successfully create adapter with SecRandomCopyBytes")

        val adapter = result.getOrThrow()

        // Test large byte generation to stress SecRandomCopyBytes
        val largeBytes = adapter.nextBytes(1024).getOrThrow()
        assertEquals(1024, largeBytes.size, "Should generate correct size")

        // Verify randomness - highly unlikely all bytes are the same
        val firstByte = largeBytes.first()
        assertFalse(largeBytes.all { it == firstByte }, "Large byte array should have variety")
    }

    /**
     * Test thread safety with concurrent access.
     */
    @Test
    fun testThreadSafety() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test concurrent access (simplified for single-threaded test)
        repeat(10) {
            val result = secureRandom.nextInt()
            assertTrue(result.isSuccess, "Concurrent access should succeed")
        }
    }

    /**
     * Test consistency between multiple adapter instances.
     */
    @Test
    fun testMultipleAdapterInstances() {
        val adapter1 = AppleSecureRandomAdapter.create().getOrThrow()
        val adapter2 = AppleSecureRandomAdapter.create().getOrThrow()

        // Both should work independently
        val bytes1 = adapter1.nextBytes(16).getOrThrow()
        val bytes2 = adapter2.nextBytes(16).getOrThrow()

        assertEquals(16, bytes1.size, "First adapter should generate correct size")
        assertEquals(16, bytes2.size, "Second adapter should generate correct size")

        // They should generate different values (extremely high probability)
        assertFalse(bytes1.contentEquals(bytes2), "Independent adapters should generate different values")
    }

    /**
     * Test edge cases for bounded generation.
     */
    @Test
    fun testBoundedGenerationEdgeCases() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test bound = 1 (should always return 0)
        val bound1Result = secureRandom.nextInt(1)
        assertTrue(bound1Result.isSuccess, "nextInt(1) should succeed")
        assertEquals(0, bound1Result.getOrThrow(), "nextInt(1) should return 0")

        // Test long bound = 1
        val longBound1Result = secureRandom.nextLong(1L)
        assertTrue(longBound1Result.isSuccess, "nextLong(1L) should succeed")
        assertEquals(0L, longBound1Result.getOrThrow(), "nextLong(1L) should return 0")

        // Test min == max - 1 (range of 1)
        val rangeResult = secureRandom.nextInt(5, 6)
        assertTrue(rangeResult.isSuccess, "nextInt(5, 6) should succeed")
        assertEquals(5, rangeResult.getOrThrow(), "nextInt(5, 6) should return 5")
    }

    /**
     * Test direct SecRandomCopyBytes API verification.
     */
    @Test
    fun testSecRandomCopyBytesAPIVerification() {
        val testHelper = AppleTestHelper.create("iOS")

        // Test SecRandomCopyBytes availability
        val apiResult = testHelper.verifySecRandomCopyBytesAvailability()
        println("iOS SecRandomCopyBytes API verification: $apiResult")

        when (apiResult) {
            is AppleSecRandomResult.Available -> {
                println("✅ iOS SecRandomCopyBytes API is available and working")
                assertTrue(true) // Test passes
            }
            is AppleSecRandomResult.Failed -> {
                println("❌ SecRandomCopyBytes failed with status: ${apiResult.status}")
                assertTrue(false, "iOS SecRandomCopyBytes API failed with status: ${apiResult.status}")
            }
            is AppleSecRandomResult.Exception -> {
                println("⚠️ Exception during SecRandomCopyBytes verification: ${apiResult.message}")
                // Don't fail for exceptions, but log them
            }
        }
    }

    /**
     * Test comprehensive iOS platform verification.
     */
    @Test
    fun testComprehensiveIOSPlatformVerification() {
        val testHelper = AppleTestHelper.create("iOS")

        println("=== iOS Platform Verification ===")

        // 1. SecRandomCopyBytes API verification
        val apiAvail = testHelper.verifySecRandomCopyBytesAvailability()
        assertTrue(apiAvail is AppleSecRandomResult.Available, "SecRandomCopyBytes must be available")
        println("✅ SecRandomCopyBytes API: $apiAvail")

        // 2. Platform information
        val platformInfo = testHelper.getApplePlatformInfo()
        println("✅ Platform info: $platformInfo")

        // 3. Security framework verification
        val frameworkResult = testHelper.verifySecurityFrameworkConstants()
        println("ℹ️ Security framework: $frameworkResult")

        // 4. API size testing
        val sizeResults = testHelper.testSecRandomCopyBytesSizes()
        val allSizesWork = sizeResults.values.all { it }
        assertTrue(allSizesWork, "All buffer sizes should work with SecRandomCopyBytes")
        println("✅ API size compatibility: $allSizesWork")

        println("=== iOS Platform Verification Complete ===")
    }
}