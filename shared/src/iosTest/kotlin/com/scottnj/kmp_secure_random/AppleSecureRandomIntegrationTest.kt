package com.scottnj.kmp_secure_random

import kotlin.test.*
import kotlin.math.*

/**
 * Integration tests for Apple SecureRandom implementation on iOS.
 * Tests real Apple SecRandomCopyBytes API integration and statistical properties.
 */
class AppleSecureRandomIntegrationTest {

    /**
     * Test real SecRandomCopyBytes API integration.
     */
    @Test
    fun testSecRandomCopyBytesAPIIntegration() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test various byte sizes to ensure SecRandomCopyBytes works correctly
        val sizes = listOf(1, 4, 8, 16, 32, 64, 128, 256, 512, 1024)

        for (size in sizes) {
            val result = secureRandom.nextBytes(size)
            assertTrue(result.isSuccess, "Should generate $size bytes successfully")

            val bytes = result.getOrThrow()
            assertEquals(size, bytes.size, "Generated array should have correct size")

            // Very basic randomness check - not all bytes should be the same
            if (size > 1) {
                val firstByte = bytes[0]
                assertFalse(bytes.all { it == firstByte }, "Not all bytes in $size-byte array should be identical")
            }
        }
    }

    /**
     * Test basic statistical distribution of generated bytes.
     */
    @Test
    fun testBasicByteDistribution() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Generate a reasonable sample size
        val sampleSize = 1000
        val bytes = secureRandom.nextBytes(sampleSize).getOrThrow()

        // Count occurrences of each byte value
        val counts = IntArray(256) { 0 }
        for (byte in bytes) {
            counts[byte.toUByte().toInt()]++
        }

        // Basic statistical check - each byte value should appear at least occasionally
        // We expect roughly sampleSize/256 occurrences per value, but allow for variance
        val expectedFrequency = sampleSize / 256.0
        val tolerance = expectedFrequency * 0.7 // Allow 70% variance

        // Count how many byte values appear with reasonable frequency
        val reasonableCount = counts.count { it >= (expectedFrequency - tolerance) && it <= (expectedFrequency + tolerance) * 2 }

        // At least 50% of byte values should appear with reasonable frequency
        assertTrue(reasonableCount >= 128, "Byte distribution should be reasonably uniform")
    }

    /**
     * Test statistical properties of integer generation.
     */
    @Test
    fun testIntegerStatisticalProperties() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test bounded integer distribution
        val bound = 10
        val sampleSize = 1000
        val counts = IntArray(bound) { 0 }

        repeat(sampleSize) {
            val value = secureRandom.nextInt(bound).getOrThrow()
            assertTrue(value >= 0 && value < bound, "Value should be in range [0, $bound)")
            counts[value]++
        }

        // Each value should appear at least once in a large sample
        val expectedFrequency = sampleSize / bound.toDouble()
        val tolerance = expectedFrequency * 0.5 // Allow 50% variance

        val reasonableCount = counts.count { it >= (expectedFrequency - tolerance) }
        assertTrue(reasonableCount >= bound / 2, "Integer distribution should be reasonably uniform")
    }

    /**
     * Test performance characteristics of Apple SecRandomCopyBytes.
     */
    @Test
    fun testPerformanceCharacteristics() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test generation speed for various sizes
        val sizes = listOf(1, 10, 100, 1000)

        for (size in sizes) {
            // Simple performance test without deprecated time functions
            repeat(10) {
                val result = secureRandom.nextBytes(size)
                assertTrue(result.isSuccess, "Generation should succeed for size $size")
            }

            // Just verify all operations complete successfully
            assertTrue(true, "Performance test completed for size $size")
        }
    }

    /**
     * Test floating-point value properties.
     */
    @Test
    fun testFloatingPointProperties() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test float range and distribution
        val floats = (1..100).map { secureRandom.nextFloat().getOrThrow() }

        assertTrue(floats.all { it >= 0.0f && it < 1.0f }, "All floats should be in range [0.0, 1.0)")
        assertTrue(floats.any { it < 0.5f }, "Some floats should be in lower half")
        assertTrue(floats.any { it >= 0.5f }, "Some floats should be in upper half")

        // Test double range and distribution
        val doubles = (1..100).map { secureRandom.nextDouble().getOrThrow() }

        assertTrue(doubles.all { it >= 0.0 && it < 1.0 }, "All doubles should be in range [0.0, 1.0)")
        assertTrue(doubles.any { it < 0.5 }, "Some doubles should be in lower half")
        assertTrue(doubles.any { it >= 0.5 }, "Some doubles should be in upper half")
    }

    /**
     * Test boolean distribution.
     */
    @Test
    fun testBooleanDistribution() {
        val secureRandom = createSecureRandom().getOrThrow()

        val sampleSize = 200
        val booleans = (1..sampleSize).map { secureRandom.nextBoolean().getOrThrow() }

        val trueCount = booleans.count { it }
        val falseCount = booleans.count { !it }

        assertEquals(sampleSize, trueCount + falseCount, "All booleans should be accounted for")

        // Expect roughly 50/50 distribution with some tolerance
        val expectedCount = sampleSize / 2.0
        val tolerance = expectedCount * 0.3 // Allow 30% variance

        assertTrue(trueCount >= (expectedCount - tolerance), "True count should be reasonable")
        assertTrue(falseCount >= (expectedCount - tolerance), "False count should be reasonable")
    }

    /**
     * Test error handling and recovery.
     */
    @Test
    fun testErrorHandlingAndRecovery() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test that invalid operations don't break subsequent valid operations
        val invalidResult = secureRandom.nextInt(-1)
        assertTrue(invalidResult.isFailure, "Invalid operation should fail")

        // Subsequent valid operation should still work
        val validResult = secureRandom.nextInt(10)
        assertTrue(validResult.isSuccess, "Valid operation should succeed after invalid one")
    }

    /**
     * Test memory efficiency with large allocations.
     */
    @Test
    fun testMemoryEfficiency() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test reasonably large allocations
        val largeSizes = listOf(1024, 4096, 8192)

        for (size in largeSizes) {
            val result = secureRandom.nextBytes(size)
            assertTrue(result.isSuccess, "Should handle large allocation of $size bytes")

            val bytes = result.getOrThrow()
            assertEquals(size, bytes.size, "Large allocation should have correct size")

            // Basic randomness check for large arrays
            val chunkSize = 256
            val chunks = bytes.toList().chunked(chunkSize)
            val distinctChunks = chunks.map { chunk -> chunk.sumOf { it.toInt() } }.distinct().size

            // Different chunks should have different sums (high probability)
            assertTrue(distinctChunks > chunks.size / 2, "Large arrays should show diversity across chunks")
        }
    }

    /**
     * Test range generation edge cases.
     */
    @Test
    fun testRangeGenerationEdgeCases() {
        val secureRandom = createSecureRandom().getOrThrow()

        // Test large ranges
        val largeRangeResult = secureRandom.nextInt(0, 1000000)
        assertTrue(largeRangeResult.isSuccess, "Large range should work")
        val largeRangeValue = largeRangeResult.getOrThrow()
        assertTrue(largeRangeValue >= 0 && largeRangeValue < 1000000, "Large range value should be in bounds")

        // Test very large long ranges
        val largeLongRangeResult = secureRandom.nextLong(0L, 1000000000L)
        assertTrue(largeLongRangeResult.isSuccess, "Large long range should work")
        val largeLongRangeValue = largeLongRangeResult.getOrThrow()
        assertTrue(largeLongRangeValue >= 0L && largeLongRangeValue < 1000000000L, "Large long range value should be in bounds")

        // Test maximum int bound
        val maxIntResult = secureRandom.nextInt(Int.MAX_VALUE)
        assertTrue(maxIntResult.isSuccess, "Maximum int bound should work")
        val maxIntValue = maxIntResult.getOrThrow()
        assertTrue(maxIntValue >= 0 && maxIntValue < Int.MAX_VALUE, "Max int value should be in bounds")
    }

    /**
     * Test consistency and reliability over multiple iterations.
     */
    @Test
    fun testConsistencyAndReliability() {
        // Test that adapter creation is reliable
        repeat(5) {
            val result = AppleSecureRandomAdapter.create()
            assertTrue(result.isSuccess, "Adapter creation should be consistently successful")
        }

        // Test that operations are consistently successful
        val secureRandom = createSecureRandom().getOrThrow()

        repeat(100) {
            val byteResult = secureRandom.nextBytes(16)
            assertTrue(byteResult.isSuccess, "Byte generation should be consistently successful")

            val intResult = secureRandom.nextInt(100)
            assertTrue(intResult.isSuccess, "Int generation should be consistently successful")

            val boolResult = secureRandom.nextBoolean()
            assertTrue(boolResult.isSuccess, "Boolean generation should be consistently successful")
        }
    }
}